<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simple Tetris</title>
  <style>
    :root { --bg:#0d0f14; --panel:#141926; --text:#e6edf3; --muted:#99a3b1; --accent:#7cc7ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; background:linear-gradient(180deg,#0b1020,#0a0d14); color:var(--text); display:grid; min-height:100svh; place-items:center; }
    .wrap { display:grid; grid-template-columns: 1fr auto; gap:18px; padding:18px; width:min(1100px,95vw); }
    .panel { background:var(--panel); border:1px solid #1f2940; border-radius:16px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    canvas { background:#0b0f1a; border-radius:12px; display:block; }
    .sidebar { width:300px; display:grid; gap:12px; align-content:start; }
    h1 { font-size:20px; margin:0 0 6px; letter-spacing:.3px; color:#b9d7ff; }
    .stat { display:flex; justify-content:space-between; background:#0f1422; padding:10px 12px; border-radius:12px; border:1px solid #1f2940; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f1422; border:1px solid #26324f; padding:2px 6px; border-radius:6px; color:#cfe6ff; }
    .grid { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
    .controls { font-size:14px; color:var(--muted); line-height:1.5; }
    .btns { display:flex; gap:8px; }
    button { cursor:pointer; border:1px solid #2a3a5f; background:#0f1422; color:var(--text); padding:10px 12px; border-radius:10px; font-weight:600; }
    button:hover { border-color:#3b5aa6; }
    .mini { display:grid; grid-template-columns:auto 1fr; gap:8px; align-items:center; }
    #nextCanvas, #holdCanvas { background:#0b0f1a; border-radius:8px; border:1px solid #1f2940; }
    footer { text-align:center; color:var(--muted); font-size:12px; margin-top:8px; }
    @media (max-width: 840px){ .wrap { grid-template-columns: 1fr; } .sidebar { width:auto; grid-template-columns:1fr 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <canvas id="game" width="300" height="600" aria-label="Tetris board"></canvas>
    </div>
    <div class="sidebar">
      <div class="panel">
        <h1>Simple Tetris</h1>
        <div class="grid">
          <div class="stat"><span>スコア</span><strong id="score">0</strong></div>
          <div class="stat"><span>ライン</span><strong id="lines">0</strong></div>
          <div class="stat"><span>レベル</span><strong id="level">1</strong></div>
          <div class="stat"><span>状態</span><strong id="state">PLAY</strong></div>
        </div>
        <div class="mini" style="margin-top:10px;">
          <span>Next</span>
          <canvas id="nextCanvas" width="120" height="120"></canvas>
        </div>
        <div class="mini">
          <span>Hold</span>
          <canvas id="holdCanvas" width="120" height="120"></canvas>
        </div>
        <div class="btns" style="margin-top:10px;">
          <button id="btnRestart">リスタート <span class="kbd">R</span></button>
          <button id="btnPause">一時停止 <span class="kbd">P</span></button>
        </div>
      </div>
      <div class="panel controls">
        <strong>操作方法</strong><br>
        <span class="kbd">← →</span> 移動 / <span class="kbd">↓</span> ソフトドロップ<br>
        <span class="kbd">↑</span> 回転 / <span class="kbd">SPACE</span> ハードドロップ<br>
        <span class="kbd">C</span> ホールド / <span class="kbd">P</span> ポーズ / <span class="kbd">R</span> リスタート
      </div>
      <footer>純HTML+JSの単一ファイル。ブラウザでそのまま動きます。</footer>
    </div>
  </div>

<script>
(function(){
  const COLS = 10, ROWS = 20, TILE = 30;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('nextCanvas');
  const nctx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('holdCanvas');
  const hctx = holdCanvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const stateEl = document.getElementById('state');

  const COLORS = { I:'#31c7ef', J:'#2a6bf2', L:'#f2a33c', O:'#f7d23e', S:'#42d36f', T:'#b155e0', Z:'#ef3e53', G:'#182032' };

  function* bagGenerator(){
    const pieces = ['I','J','L','O','S','T','Z'];
    while(true){
      const bag = pieces.slice();
      for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; }
      yield* bag;
    }
  }
  const bag = bagGenerator();

  const SHAPES = {
    I:[ [0,1],[1,1],[2,1],[3,1] ],
    J:[ [0,0],[0,1],[1,1],[2,1] ],
    L:[ [2,0],[0,1],[1,1],[2,1] ],
    O:[ [1,0],[2,0],[1,1],[2,1] ],
    S:[ [1,0],[2,0],[0,1],[1,1] ],
    T:[ [1,0],[0,1],[1,1],[2,1] ],
    Z:[ [0,0],[1,0],[1,1],[2,1] ],
  };

  function rotate(shape, dir){
    const xs = shape.map(p=>p[0]);
    const ys = shape.map(p=>p[1]);
    const minx = Math.min(...xs), miny=Math.min(...ys);
    const norm = shape.map(([x,y])=>[x-minx, y-miny]);
    const w = Math.max(...norm.map(p=>p[0]))+1;
    const h = Math.max(...norm.map(p=>p[1]))+1;
    let rotated = norm.map(([x,y])=> dir>0 ? [h-1-y,x] : [y,w-1-x]);
    const rx = Math.min(...rotated.map(p=>p[0]));
    const ry = Math.min(...rotated.map(p=>p[1]));
    rotated = rotated.map(([x,y])=>[x-rx,y-ry]);
    return rotated;
  }

  function createMatrix(w,h){ return Array.from({length:h},()=>Array(w).fill(null)); }
  let grid = createMatrix(COLS, ROWS);

  let current = null;
  let nextType = bag.next().value;
  let holdType = null;
  let canHold = true;

  let score=0, lines=0, level=1;
  let dropInterval = 1000;
  let lastTime = 0;
  let acc = 0;
  let paused = false;
  let over = false;

  function spawn(){
    const type = nextType;
    nextType = bag.next().value;
    const shape = SHAPES[type].map(p=>p.slice());
    current = { type, shape, x:3, y:0 };
    if(collide(grid, current)){ gameOver(); }
    drawSide();
    canHold = true;
  }

  function hardDrop(){ if(!current) return; while(move(0,1)); lock(); }

  function hold(){
    if(!canHold) return;
    const temp = holdType;
    holdType = current.type;
    if(temp){
      const shape = SHAPES[temp].map(p=>p.slice());
      current = { type: temp, shape, x:3, y:0 };
      if(collide(grid,current)) gameOver();
    }else{ spawn(); }
    canHold = false;
    drawSide();
  }

  function collide(matrix, piece){
    return piece.shape.some(([x,y])=>{
      const px = x + piece.x, py = y + piece.y;
      return px<0 || px>=COLS || py>=ROWS || (py>=0 && matrix[py][px]);
    });
  }

  function merge(matrix, piece){
    piece.shape.forEach(([x,y])=>{
      const px = x + piece.x, py = y + piece.y;
      if(py>=0) matrix[py][px] = piece.type;
    });
  }

  function sweep(){
    let cleared = 0;
    outer: for(let y=ROWS-1; y>=0; y--){
      for(let x=0;x<COLS;x++) if(!grid[y][x]) continue outer;
      const row = grid.splice(y,1)[0].fill(null);
      grid.unshift(row);
      cleared++;
      y++;
    }
    if(cleared){
      lines += cleared;
      const points = [0,100,300,500,800][cleared] || cleared*200;
      score += points * level;
      level = 1 + Math.floor(lines/10);
      dropInterval = Math.max(100, 1000 - (level-1)*80);
      updateUI();
    }
  }

  function updateUI(){
    scoreEl.textContent = score;
    linesEl.textContent = lines;
    levelEl.textContent = level;
    stateEl.textContent = over ? 'OVER' : (paused ? 'PAUSE' : 'PLAY');
  }

  function move(dx,dy){
    if(!current) return false;
    current.x += dx; current.y += dy;
    if(collide(grid,current)){ current.x -= dx; current.y -= dy; return false; }
    return true;
  }

  function rotateCurrent(dir){
    if(!current) return;
    const prev = current.shape.map(p=>p.slice());
    current.shape = rotate(current.shape, dir);
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      current.x += k;
      if(!collide(grid,current)) return;
      current.x -= k;
    }
    current.shape = prev;
  }

  function lock(){ merge(grid,current); sweep(); spawn(); }

  function drawBlock(gx, gy, color, ctx2d){
    const s = ctx2d === ctx ? TILE : 24;
    const px = gx*s, py = gy*s;
    ctx2d.fillStyle = color;
    ctx2d.fillRect(px,py,s,s);
    ctx2d.fillStyle = 'rgba(255,255,255,0.08)';
    ctx2d.fillRect(px,py,s,s*0.25);
    ctx2d.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx2d.strokeRect(px+0.5,py+0.5,s-1,s-1);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        ctx.fillStyle = '#0e1322';
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        const t = grid[y][x];
        if(t) drawBlock(x,y,COLORS[t], ctx);
      }
    }
    if(current){
      let ghostY = current.y;
      while(true){
        ghostY++;
        const test = { ...current, y: ghostY };
        if(collide(grid,test)){ ghostY--; break; }
      }
      ctx.globalAlpha = 0.25;
      current.shape.forEach(([x,y])=> drawBlock(current.x+x, ghostY+y, COLORS[current.type], ctx));
      ctx.globalAlpha = 1;
      current.shape.forEach(([x,y])=> drawBlock(current.x+x, current.y+y, COLORS[current.type], ctx));
    }
  }

  function drawMini(ctx2d, type){
    ctx2d.clearRect(0,0,120,120);
    if(!type) return;
    const shape = SHAPES[type];
    const xs = shape.map(p=>p[0]), ys=shape.map(p=>p[1]);
    const w = Math.max(...xs)-Math.min(...xs)+1;
    const h = Math.max(...ys)-Math.min(...ys)+1;
    const offx = Math.floor((5-w)/2);
    const offy = Math.floor((5-h)/2);
    shape.forEach(([x,y])=> drawBlock(x+offx, y+offy, COLORS[type], ctx2d));
  }

  function drawSide(){ drawMini(nctx, nextType); drawMini(hctx, holdType); updateUI(); }

  function gameOver(){ over = true; paused = true; stateEl.textContent = 'OVER'; }

  function restart(){
    grid = createMatrix(COLS, ROWS);
    score=0; lines=0; level=1; dropInterval=1000; over=false; paused=false;
    nextType = bag.next().value; holdType=null; canHold=true; current=null;
    spawn(); updateUI();
  }

  function update(t){
    if(!paused && !over){
      const dt = t - lastTime; lastTime = t; acc += dt;
      if(acc > dropInterval){ if(!move(0,1)) lock(); acc = 0; }
      draw();
    }
    requestAnimationFrame(update);
  }

  window.addEventListener('keydown', (e)=>{
    if(over && e.key.toLowerCase()!=='r') return;
    switch(e.key){
      case 'ArrowLeft': move(-1,0); break;
      case 'ArrowRight': move(1,0); break;
      case 'ArrowDown': move(0,1); break;
      case 'ArrowUp': rotateCurrent(1); break;
      case ' ': e.preventDefault(); hardDrop(); break;
      case 'p': case 'P': paused = !paused; updateUI(); break;
      case 'r': case 'R': restart(); break;
      case 'c': case 'C': hold(); break;
    }
  });

  document.getElementById('btnRestart').onclick = restart;
  document.getElementById('btnPause').onclick = ()=>{ paused=!paused; updateUI(); };

  spawn();
  requestAnimationFrame(update);
})();
</script>
</body>
</html>
